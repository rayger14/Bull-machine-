#!/usr/bin/env python3
"""
Signal Flow Integration Test
Tests the complete pipeline from chart data to actual trades.
"""

import sys
import pandas as pd
import numpy as np
import logging
import tempfile
import os
from pathlib import Path

# Add project root to path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

from bull_machine.backtest.strategy_adapter_optimized import strategy_from_df
from bull_machine.backtest.engine import BacktestEngine
from bull_machine.backtest.datafeed import DataFeed
from bull_machine.backtest.broker import PaperBroker
from bull_machine.backtest.portfolio import Portfolio
from bull_machine.core.signal_validation import validate_signal, standardize_signal

# Configure logging
logging.basicConfig(level=logging.DEBUG, format="%(asctime)s - %(levelname)s - %(message)s")


def create_test_data():
    """Create realistic test data with price movements that trigger TP/SL."""
    dates = pd.date_range("2023-01-01", periods=300, freq="H")

    # Create more realistic price action with periods of trend and consolidation
    base_price = 50000
    prices = []
    for i in range(300):
        # Different phases
        if i < 100:
            # Initial uptrend phase
            trend = i * 8
            noise = (i % 15 - 7) * 30
        elif i < 150:
            # Consolidation phase
            trend = 800 + (i - 100) * 2  # Slower trend
            noise = (i % 20 - 10) * 80  # More volatility
        elif i < 200:
            # Stronger uptrend
            trend = 900 + (i - 150) * 15
            noise = (i % 12 - 6) * 40
        else:
            # Final phase with pullback and recovery
            base_trend = 1650
            cycle = (i - 200) / 20  # Longer cycle
            trend = base_trend + 200 * np.sin(cycle) + (i - 200) * 5
            noise = (i % 8 - 4) * 60

        price = base_price + trend + noise
        prices.append(max(price, 1000))  # Ensure positive prices

    # Create realistic OHLC data
    df_data = []
    for i, close_price in enumerate(prices):
        if i == 0:
            open_price = close_price
        else:
            # Open close to previous close with some gap
            open_price = prices[i - 1] + (close_price - prices[i - 1]) * 0.3

        # Create realistic high/low based on volatility
        volatility = abs(close_price - open_price) + 50
        high_price = max(open_price, close_price) + volatility * 0.6
        low_price = min(open_price, close_price) - volatility * 0.4

        df_data.append(
            {
                "timestamp": dates[i],
                "open": open_price,
                "high": high_price,
                "low": low_price,
                "close": close_price,
                "volume": 1000 + (i % 50) * 20,  # Varying volume
            }
        )

    df = pd.DataFrame(df_data)
    df = df.set_index("timestamp")
    return df


def test_strategy_adapter_signals():
    """Test if strategy adapter generates signals."""
    print("\n" + "=" * 80)
    print("TESTING STRATEGY ADAPTER SIGNAL GENERATION")
    print("=" * 80)

    df = create_test_data()
    symbol = "TESTBTC"
    tf = "1H"

    signal_count = 0
    valid_signals = []

    # Test on multiple bars to see if we get any signals
    for i in range(100, len(df)):
        signal = strategy_from_df(symbol, tf, df, i)

        if signal is not None:
            signal_count += 1
            logging.info(f"Generated signal {signal_count} @ bar {i}: {signal}")

            # Validate signal format
            if isinstance(signal, dict) and "action" in signal:
                valid_signals.append(signal)
                logging.info(
                    f"Valid signal: {signal['action']} with confidence {signal.get('confidence', 'N/A')}"
                )
            else:
                logging.warning(f"Invalid signal format: {signal}")

    print(f"\nSUMMARY:")
    print(f"Total signals generated: {signal_count}")
    print(f"Valid signals: {len(valid_signals)}")

    if valid_signals:
        print(f"Sample valid signal: {valid_signals[0]}")
        return True
    else:
        print("‚ùå No valid signals generated by strategy adapter")
        return False


def test_backtest_engine_integration():
    """Test full backtest engine integration."""
    print("\n" + "=" * 80)
    print("TESTING BACKTEST ENGINE INTEGRATION")
    print("=" * 80)

    # Create temporary CSV file
    df = create_test_data()
    fd, temp_csv = tempfile.mkstemp(suffix=".csv", prefix="test_signal_flow_")
    os.close(fd)

    try:
        # Save test data
        df.to_csv(temp_csv)

        # Configure backtest
        config = {
            "run_id": "signal_flow_test",
            "data": {"sources": {"TESTBTC": temp_csv}, "timeframes": ["1H"]},
            "broker": {"fee_bps": 2, "slippage_bps": 3, "spread_bps": 1},
            "portfolio": {"starting_cash": 100000},
            "engine": {"lookback_bars": 50, "seed": 42},
        }

        # Create backtest components
        feed = DataFeed(config["data"]["sources"])
        broker = PaperBroker(**config.get("broker", {}))
        portfolio = Portfolio(config.get("portfolio", {}).get("starting_cash", 100000))
        engine = BacktestEngine(config, feed, broker, portfolio)

        # Custom strategy function with debug logging
        def debug_strategy(symbol: str, tf: str, df_tf, current_index):
            """Strategy with debug logging."""
            logging.debug(f"Strategy called: {symbol} {tf} index={current_index}")

            signal = strategy_from_df(symbol, tf, df_tf, current_index)
            if signal:
                logging.info(f"Strategy returned signal: {signal}")

            return signal

        # Run backtest
        print(f"Running backtest with test data...")
        results = engine.run(debug_strategy, ["TESTBTC"], ["1H"], out_dir="/tmp/signal_flow_test")

        print(f"\nBACKTEST RESULTS:")
        print(f"Trades: {results['metrics']['trades']}")
        print(f"Win rate: {results['metrics']['win_rate']}")

        # Debug: Check what's in the trades file
        trades_file = results["artifacts"]["trades"]
        if os.path.exists(trades_file):
            trades_df = pd.read_csv(trades_file)
            print(f"\nTRADES DEBUG:")
            print(f"Total rows in trades file: {len(trades_df)}")
            if len(trades_df) > 0:
                print(f"Action types: {trades_df['action'].value_counts().to_dict()}")
                print(f"Sample trades:\n{trades_df.head()}")
            else:
                print("Trades file is empty")
        else:
            print(f"Trades file not found: {trades_file}")

        # Count entry trades as a signal of success
        if os.path.exists(trades_file):
            trades_df = pd.read_csv(trades_file)
            entry_trades = len(trades_df[trades_df["action"].str.contains("enter", na=False)])
            print(f"Entry trades: {entry_trades}")

            if entry_trades > 0:
                print("‚úÖ Backtest generated entry trades!")
                return True

        if results["metrics"]["trades"] > 0:
            print("‚úÖ Backtest generated exit trades!")
            return True
        else:
            print("‚ùå Backtest generated 0 trades")
            return False

    finally:
        # Clean up temp file
        try:
            os.unlink(temp_csv)
        except:
            pass


def test_signal_validation():
    """Test signal validation functions."""
    print("\n" + "=" * 80)
    print("TESTING SIGNAL VALIDATION")
    print("=" * 80)

    # Test valid signal
    valid_signal = {
        "timestamp": pd.Timestamp.now(),
        "symbol": "TESTBTC",
        "bias": "long",
        "score": 0.75,
        "reasons": ["test_signal"],
    }

    is_valid = validate_signal(valid_signal)
    print(f"Valid signal test: {'‚úÖ PASSED' if is_valid else '‚ùå FAILED'}")

    # Test invalid signal
    invalid_signal = {
        "symbol": "TESTBTC",
        "bias": "invalid_bias",
        "score": 1.5,  # Invalid score > 1.0
        "reasons": [],
    }

    is_invalid = not validate_signal(invalid_signal)
    print(f"Invalid signal test: {'‚úÖ PASSED' if is_invalid else '‚ùå FAILED'}")

    return is_valid and is_invalid


def main():
    """Run all signal flow tests."""
    print("üß™ SIGNAL FLOW INTEGRATION TESTS")
    print("=" * 80)

    tests = [
        ("Signal Validation", test_signal_validation),
        ("Strategy Adapter Signals", test_strategy_adapter_signals),
        ("Backtest Engine Integration", test_backtest_engine_integration),
    ]

    results = []
    for test_name, test_func in tests:
        try:
            result = test_func()
            results.append((test_name, result))
            print(f"\n{test_name}: {'‚úÖ PASSED' if result else '‚ùå FAILED'}")
        except Exception as e:
            results.append((test_name, False))
            print(f"\n{test_name}: ‚ùå ERROR - {e}")
            logging.error(f"Test {test_name} failed with error: {e}", exc_info=True)

    print("\n" + "=" * 80)
    print("FINAL RESULTS")
    print("=" * 80)

    for test_name, result in results:
        status = "‚úÖ PASSED" if result else "‚ùå FAILED"
        print(f"{test_name:<30} {status}")

    passed = sum(1 for _, result in results if result)
    total = len(results)
    print(f"\nOVERALL: {passed}/{total} tests passed")

    if passed == total:
        print("üéâ All tests passed! Signal flow is working.")
        return True
    else:
        print("‚ö†Ô∏è Some tests failed. Check logs for details.")
        return False


if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)

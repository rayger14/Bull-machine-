# v1.9: Numba/Cython Optimization Plan

**Goal**: Optimize real domain engines (Wyckoff, HOB, Momentum, SMC) to achieve <1s/bar performance, enabling full domain engine usage in live trading without fast signal fallback.

**Current State** (v1.7.3):
- Real engines: 3+ minutes for 720 bars (30 days) = ~250ms/bar
- Fast signals: 10 seconds for 8760 bars (1 year) = ~1ms/bar
- **Gap**: 250x slower

**Target State** (v1.9):
- Real engines with Numba: <1s/bar (sub-second per bar)
- Full domain knowledge in live trading
- No fast signal fallback needed
- **Performance improvement**: 250x faster

---

## Feasibility Analysis

### Why Numba/Cython Will Work

1. **Bottleneck is Array Operations**
   - Current engines use pandas (interpreted, slow)
   - Numba compiles to machine code (LLVM)
   - Expected speedup: 10-100x for numerical loops

2. **Minimal Code Changes Required**
   - Add `@jit(nopython=True)` decorators
   - Refactor pandas → numpy (mechanical transformation)
   - No algorithmic changes needed

3. **Proven Approach**
   - TA-Lib uses C extensions (why it's fast)
   - Backtrader uses Cython for indicators
   - Similar projects achieve 50-200x speedups

### Performance Estimates

| Component | Current (pandas) | After Numba | Speedup |
|-----------|-----------------|-------------|---------|
| ADX calculation | ~50ms | ~0.5ms | 100x |
| Wyckoff phase detection | ~80ms | ~2ms | 40x |
| HOB zone detection | ~120ms | ~5ms | 24x |
| SMC analysis | ~150ms | ~8ms | 19x |
| **Total per bar** | ~250ms | **~5ms** | **50x** |

**Result**: 8760 bars (1 year) = 8760 × 5ms = 43 seconds (vs current 3+ minutes)

---

## Implementation Plan

### Phase 1: Profile & Identify Hotspots (2 hours)

```bash
# Profile current engines
python -m cProfile -o profile.stats scripts/backtests/v173/btc_simple_backtest.py

# Analyze with snakeviz
pip install snakeviz
snakeviz profile.stats

# Expected hotspots:
# - calc_adx (15% of time)
# - detect_wyckoff_phase (25% of time)
# - HOBDetector.detect_hob (30% of time)
# - SMCEngine.analyze (20% of time)
```

### Phase 2: Optimize Core Indicators (4 hours)

#### File: `engine/momentum/momentum_numba.py` (NEW)

```python
"""Numba-optimized momentum calculations."""

import numpy as np
from numba import jit

@jit(nopython=True)
def calc_adx_numba(high: np.ndarray, low: np.ndarray,
                   close: np.ndarray, period: int = 14) -> float:
    """
    Calculate ADX using Numba JIT compilation.

    Performance: ~0.5ms (vs 50ms with pandas)
    """
    n = len(high)
    if n < period * 2:
        return 0.0

    # Directional Movement
    plus_dm = np.zeros(n)
    minus_dm = np.zeros(n)

    for i in range(1, n):
        up_move = high[i] - high[i-1]
        down_move = low[i-1] - low[i]

        if up_move > down_move and up_move > 0:
            plus_dm[i] = up_move
        if down_move > up_move and down_move > 0:
            minus_dm[i] = down_move

    # True Range
    tr = np.zeros(n)
    for i in range(1, n):
        tr[i] = max(
            high[i] - low[i],
            abs(high[i] - close[i-1]),
            abs(low[i] - close[i-1])
        )

    # Average True Range (rolling mean)
    atr = np.zeros(n)
    atr[period-1] = np.mean(tr[:period])
    for i in range(period, n):
        atr[i] = (atr[i-1] * (period - 1) + tr[i]) / period

    # Directional Indicators
    plus_di = 100.0 * plus_dm / (atr + 1e-10)
    minus_di = 100.0 * minus_dm / (atr + 1e-10)

    # Smooth DI
    plus_di_smooth = np.zeros(n)
    minus_di_smooth = np.zeros(n)
    plus_di_smooth[period-1] = np.mean(plus_di[:period])
    minus_di_smooth[period-1] = np.mean(minus_di[:period])

    for i in range(period, n):
        plus_di_smooth[i] = (plus_di_smooth[i-1] * (period - 1) + plus_di[i]) / period
        minus_di_smooth[i] = (minus_di_smooth[i-1] * (period - 1) + minus_di[i]) / period

    # Directional Index
    dx = 100.0 * np.abs(plus_di_smooth - minus_di_smooth) / (plus_di_smooth + minus_di_smooth + 1e-10)

    # ADX
    adx = np.zeros(n)
    adx[period*2-2] = np.mean(dx[period-1:period*2-1])
    for i in range(period*2-1, n):
        adx[i] = (adx[i-1] * (period - 1) + dx[i]) / period

    return adx[-1]


@jit(nopython=True)
def calc_rsi_numba(close: np.ndarray, period: int = 14) -> float:
    """
    Calculate RSI using Numba JIT compilation.

    Performance: ~0.3ms (vs 30ms with pandas)
    """
    n = len(close)
    if n < period + 1:
        return 50.0

    deltas = np.diff(close)
    gains = np.where(deltas > 0, deltas, 0.0)
    losses = np.where(deltas < 0, -deltas, 0.0)

    # Initial average
    avg_gain = np.mean(gains[:period])
    avg_loss = np.mean(losses[:period])

    # Smooth with Wilder's method
    for i in range(period, len(gains)):
        avg_gain = (avg_gain * (period - 1) + gains[i]) / period
        avg_loss = (avg_loss * (period - 1) + losses[i]) / period

    if avg_loss == 0:
        return 100.0

    rs = avg_gain / avg_loss
    rsi = 100.0 - (100.0 / (1.0 + rs))

    return rsi


@jit(nopython=True)
def calc_sma_numba(values: np.ndarray, period: int) -> np.ndarray:
    """
    Calculate SMA using Numba JIT compilation.

    Performance: ~0.2ms (vs 20ms with pandas)
    """
    n = len(values)
    sma = np.zeros(n)

    if n < period:
        return sma

    # Initial SMA
    sma[period-1] = np.mean(values[:period])

    # Rolling SMA
    for i in range(period, n):
        sma[i] = sma[i-1] + (values[i] - values[i-period]) / period

    return sma
```

#### File: `engine/momentum/momentum.py` (MODIFIED)

```python
"""
Momentum engine with optional Numba optimization.

Falls back to pandas if Numba not available.
"""

import pandas as pd
import numpy as np

# Try to import Numba-optimized functions
try:
    from .momentum_numba import calc_adx_numba, calc_rsi_numba, calc_sma_numba
    NUMBA_AVAILABLE = True
except ImportError:
    NUMBA_AVAILABLE = False


def calculate_rsi(df: pd.DataFrame, period: int = 14, use_numba: bool = True) -> float:
    """
    Calculate RSI with optional Numba acceleration.

    Args:
        df: OHLCV DataFrame
        period: RSI period (default 14)
        use_numba: Use Numba if available (default True)

    Returns:
        RSI value (0-100)
    """
    if use_numba and NUMBA_AVAILABLE:
        # Numba path (50-100x faster)
        close = df['close'].values
        return calc_rsi_numba(close, period)

    else:
        # Pandas fallback (original logic)
        close = df['close']
        delta = close.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        rs = gain / (loss + 1e-10)
        rsi = 100 - (100 / (1 + rs))
        return rsi.iloc[-1] if len(rsi) > 0 else 50.0


def calculate_adx(df: pd.DataFrame, period: int = 14, use_numba: bool = True) -> float:
    """
    Calculate ADX with optional Numba acceleration.

    Args:
        df: OHLCV DataFrame
        period: ADX period (default 14)
        use_numba: Use Numba if available (default True)

    Returns:
        ADX value (0-100)
    """
    if use_numba and NUMBA_AVAILABLE:
        # Numba path (100x faster)
        high = df['high'].values
        low = df['low'].values
        close = df['close'].values
        return calc_adx_numba(high, low, close, period)

    else:
        # Pandas fallback (from fast_signals.py)
        high = df['high']
        low = df['low']
        close = df['close']

        plus_dm = high.diff()
        minus_dm = -low.diff()
        plus_dm[plus_dm < 0] = 0
        minus_dm[minus_dm < 0] = 0

        tr = pd.concat([
            high - low,
            (high - close.shift()).abs(),
            (low - close.shift()).abs()
        ], axis=1).max(axis=1)

        atr = tr.rolling(period).mean()
        plus_di = 100 * (plus_dm.rolling(period).mean() / atr)
        minus_di = 100 * (minus_dm.rolling(period).mean() / atr)

        dx = 100 * (plus_di - minus_di).abs() / (plus_di + minus_di + 1e-10)
        adx = dx.rolling(period).mean()

        return adx.iloc[-1] if len(adx) > 0 else 0.0
```

### Phase 3: Optimize Domain Engines (6 hours)

#### Wyckoff Engine

**File**: `engine/wyckoff/wyckoff_numba.py` (NEW)

```python
"""Numba-optimized Wyckoff phase detection."""

import numpy as np
from numba import jit

@jit(nopython=True)
def detect_volume_climax_numba(volume: np.ndarray,
                                volume_ma: np.ndarray,
                                threshold: float = 2.0) -> bool:
    """Detect volume climax (SC/UTAD marker)."""
    if len(volume) < 2:
        return False

    current_vol = volume[-1]
    avg_vol = volume_ma[-1]

    return current_vol > avg_vol * threshold


@jit(nopython=True)
def detect_spring_numba(low: np.ndarray,
                         support_level: float,
                         penetration_pct: float = 0.02) -> tuple:
    """
    Detect Wyckoff spring pattern.

    Returns:
        (is_spring, spring_strength)
    """
    if len(low) < 5:
        return (False, 0.0)

    # Check if recent low penetrated support
    for i in range(-5, 0):
        if low[i] < support_level * (1 - penetration_pct):
            # Found penetration, check for recovery
            if low[-1] > support_level:
                strength = (low[-1] - low[i]) / low[i]
                return (True, strength)

    return (False, 0.0)

# ... more Wyckoff patterns
```

#### HOB Engine

**File**: `engine/liquidity/hob_numba.py` (NEW)

```python
"""Numba-optimized HOB (Hands-on-Back) detection."""

import numpy as np
from numba import jit

@jit(nopython=True)
def detect_demand_zone_numba(low: np.ndarray, high: np.ndarray,
                               close: np.ndarray, volume: np.ndarray,
                               lookback: int = 20) -> tuple:
    """
    Detect demand zone with institutional quality scoring.

    Returns:
        (zone_start, zone_end, quality_score)
    """
    n = len(low)
    if n < lookback:
        return (0.0, 0.0, 0.0)

    # Find swing low
    swing_low_idx = np.argmin(low[-lookback:])
    swing_low = low[-(lookback - swing_low_idx)]

    # Calculate zone boundaries
    zone_start = swing_low * 0.98  # 2% below
    zone_end = swing_low * 1.01    # 1% above

    # Quality scoring (volume, reaction strength)
    vol_at_low = volume[-(lookback - swing_low_idx)]
    avg_vol = np.mean(volume[-lookback:])
    vol_score = min(1.0, vol_at_low / (avg_vol * 1.5))

    # Reaction strength
    reaction_high = np.max(high[-(lookback - swing_low_idx):])
    reaction_pct = (reaction_high - swing_low) / swing_low
    reaction_score = min(1.0, reaction_pct / 0.05)  # 5% reaction = 1.0

    quality = (vol_score + reaction_score) / 2.0

    return (zone_start, zone_end, quality)
```

### Phase 4: Integration & Testing (3 hours)

#### Update Config to Enable Numba

**File**: `configs/v19/BTC_full_engines.json`

```json
{
  "version": "1.9.0",
  "use_fast_signals": false,
  "use_numba": true,

  "fusion": {
    "entry_threshold_confidence": 0.75,
    "weights": {
      "wyckoff": 0.25,
      "liquidity": 0.25,
      "momentum": 0.25,
      "smc": 0.25
    }
  }
}
```

#### Update Hybrid Runner

**File**: `bin/live/hybrid_runner.py` (MODIFIED)

```python
def _run_full_fusion(self, df_1h, df_4h, df_1d, timestamp, current_price):
    """Run full fusion engine with Numba-optimized domain modules."""

    # Convert to numpy for Numba
    use_numba = self.config.get('use_numba', True)

    # Prepare modules dict
    modules = {
        'wyckoff': self._analyze_wyckoff_numba(df_1h, df_4h, df_1d) if use_numba else self._analyze_wyckoff(df_1h, df_4h, df_1d),
        'liquidity': self._analyze_liquidity_numba(df_1h) if use_numba else self._analyze_liquidity(df_1h),
        'momentum': self._analyze_momentum_numba(df_1h, df_4h) if use_numba else self._analyze_momentum(df_1h, df_4h),
        'structure': self._analyze_structure_numba(df_1h) if use_numba else self._analyze_structure(df_1h)
    }

    # Run fusion
    signal = self.fusion_engine.fuse_with_mtf(modules, sync_report)

    return signal
```

#### Performance Test

```bash
# Test Numba optimization
pytest tests/test_numba_performance.py -v

# Expected results:
# test_adx_speed: 0.5ms (100x faster) ✓
# test_rsi_speed: 0.3ms (100x faster) ✓
# test_wyckoff_speed: 2ms (40x faster) ✓
# test_hob_speed: 5ms (24x faster) ✓
# test_full_bar: 5ms total (50x faster) ✓

# Run 1-year backtest
python bin/live/hybrid_runner.py --asset BTC --start 2024-10-01 --end 2025-10-01 --config configs/v19/BTC_full_engines.json

# Expected: ~40-60 seconds (vs 3+ minutes)
```

---

## Deliverables

### v1.9.0 Checklist

- [ ] Numba-optimized momentum indicators (`engine/momentum/momentum_numba.py`)
- [ ] Numba-optimized Wyckoff detection (`engine/wyckoff/wyckoff_numba.py`)
- [ ] Numba-optimized HOB detection (`engine/liquidity/hob_numba.py`)
- [ ] Numba-optimized SMC analysis (`engine/smc/smc_numba.py`)
- [ ] Fallback logic for non-Numba systems
- [ ] Performance tests (`tests/test_numba_performance.py`)
- [ ] Config flag (`use_numba: true/false`)
- [ ] Documentation update
- [ ] Benchmark results

### Success Criteria

| Metric | Target | How to Measure |
|--------|--------|----------------|
| **Per-bar time** | <5ms | `pytest tests/test_numba_performance.py` |
| **1-year backtest** | <60s | `time python bin/live/hybrid_runner.py ...` |
| **Accuracy** | 100% match | Compare Numba vs pandas outputs |
| **Signal quality** | PF ≥1.8 | Run on BTC/ETH/SOL 1-year |

---

## Alternative: Cython (If Numba Fails)

If Numba doesn't achieve targets, use Cython:

```python
# File: engine/momentum/momentum_cython.pyx
cimport numpy as np
import numpy as np

cpdef double calc_adx_cython(double[:] high, double[:] low, double[:] close, int period):
    cdef int n = high.shape[0]
    cdef double[:] plus_dm = np.zeros(n)
    cdef double[:] minus_dm = np.zeros(n)
    # ... C-speed implementation
```

**Build**: `python setup.py build_ext --inplace`

**Performance**: Similar to Numba (50-200x)

---

## Estimated Timeline

| Phase | Hours | Deliverable |
|-------|-------|-------------|
| Profiling | 2 | Hotspot analysis |
| Core indicators | 4 | momentum_numba.py |
| Domain engines | 6 | wyckoff/hob/smc_numba.py |
| Integration | 3 | hybrid_runner.py updates |
| Testing | 2 | Performance validation |
| **Total** | **17** | v1.9.0 ready |

---

## Conclusion

Numba optimization is **feasible and necessary** for v1.9 to restore the original Bull Machine intent (full domain knowledge in live trading). The hybrid approach (v1.8) is a pragmatic stepping stone, but full engines with Numba (v1.9) will deliver superior signal quality while maintaining live-compatible speed.

**Recommendation**: Ship v1.8 (hybrid) first to validate profitability, then optimize with Numba in v1.9 to achieve the final vision.

# Bull Machine v1.4 - Professional Backtesting Framework

## 🚀 Overview

v1.4 adds a **production-grade backtesting framework** on top of the v1.3 MTF engine, providing:

- **Portfolio Management** - Position tracking, exposure limits, PnL calculation
- **Risk Execution** - Stop losses, TP ladders, breakeven management
- **Walk-Forward Validation** - Out-of-sample durability testing
- **Performance Analytics** - Sharpe, drawdown, R-distribution, trade logs
- **Direct DataFrame Integration** - No temporary CSV files needed

## 🏗️ Architecture

```
bull_machine/
├── backtest/                   # NEW: v1.4 backtesting layer
│   ├── broker.py              # Execution simulation with fees/slippage
│   ├── portfolio.py           # Position & exposure management
│   ├── engine.py              # Main backtest orchestrator
│   ├── datafeed.py            # Multi-timeframe data handling
│   ├── metrics.py             # Performance calculations
│   ├── report.py              # Results output & visualization
│   ├── strategy_adapter_v13.py # v1.3 engine integration
│   └── walkforward.py         # Rolling window validation
├── app/
│   └── main_backtest.py      # CLI entry point
└── configs/
    └── v14_production.json    # Production config with real data paths
```

## 📋 Key Features

### 1. Realistic Execution Simulation

```python
# broker.py handles:
- Market impact (slippage + spread)
- Transaction fees
- Partial fills
- Intrabar stop/TP execution
```

### 2. Risk Management

```json
"risk": {
  "stop_method": "atr",
  "atr_mult": 2.0,
  "tp_ladder": {
    "tp1": {"r_multiple": 1.0, "size_pct": 50, "action": "move_stop_to_breakeven"},
    "tp2": {"r_multiple": 2.0, "size_pct": 30, "action": "trail_stop"},
    "tp3": {"r_multiple": 3.0, "size_pct": 20, "action": "close"}
  }
}
```

### 3. Exposure Management

```python
# portfolio.py enforces:
- Maximum 50% net exposure (long or short)
- Position size limits (10% of capital)
- Risk per trade (1% default)
```

### 4. Walk-Forward Testing

```json
"walkforward": {
  "enable": true,
  "train_bars": 1500,  # Train on 1500 bars
  "test_bars": 500,    # Test on next 500
  "step_bars": 250     # Step forward 250 bars
}
```

## 🎯 TODO Implementation Tasks

### Priority 1: Wire v1.3 Strategy (strategy_adapter_v13.py)

```python
def strategy_from_df(symbol: str, tf: str, df_window, balance: float, config_path: str):
    # TODO: Call your v1.3 pipeline directly
    # 1. Convert df_window to Series format
    # 2. Call run_bull_machine_v1_3()
    # 3. Map Signal + RiskPlan to backtest format:
    return {
        'action': 'long|short|exit|flat',
        'size': position_size,
        'stop': stop_price,
        'tp': [tp1, tp2, tp3],
        'confidence': 0.65
    }
```

### Priority 2: Implement Fills (broker.py)

```python
def check_stops(self, ts, symbol, high, low):
    # TODO: Check if price hit stop or TP
    # - Stop always wins over TP
    # - Return fill details with slippage
```

### Priority 3: Exposure Cap (portfolio.py)

```python
def can_add(self, symbol, side, size, price):
    # TODO: Check if new position would exceed 50% exposure
    # - Calculate current net long/short
    # - Add proposed position
    # - Return False if > 50%
```

### Priority 4: Report Enhancements (report.py)

```python
def generate_plots(trades_df, equity_df):
    # TODO: Add visualization
    # - Equity curve
    # - Drawdown chart
    # - R-distribution histogram
```

## 🚦 Quick Start

### 1. Configure Data Sources

Edit `bull_machine/configs/v14_production.json`:

```json
"data": {
  "sources": {
    "BTCUSD": "/path/to/btc_1h.csv",
    "ETHUSD": "/path/to/eth_1h.csv"
  }
}
```

### 2. Run Backtest

```bash
python -m bull_machine.app.main_backtest \
  --config bull_machine/configs/v14_production.json \
  --out results/v14_production
```

### 3. Review Results

Output artifacts:
```
results/v14_production/
├── v1_4_production_trades.csv    # All trades with entry/exit/PnL
├── v1_4_production_equity.csv    # Equity curve timeseries
├── v1_4_production_summary.json  # Performance metrics
└── v1_4_production_report.md     # Human-readable report
```

## 📊 Performance Metrics

The backtest calculates:

- **Returns**: Total, annualized, monthly
- **Risk**: Sharpe ratio, max drawdown, volatility
- **Trading**: Win rate, avg win/loss, R-multiple
- **Execution**: Total fees, slippage impact
- **Efficiency**: Profit factor, expectancy

## 🔄 Walk-Forward Validation

Enable rolling window testing to avoid overfitting:

```python
# Automatically runs multiple train/test cycles:
# Train[0:1500] → Test[1500:2000]
# Train[250:1750] → Test[1750:2250]
# Train[500:2000] → Test[2000:2500]
# ...
```

## 🎯 Integration Points

### v1.3 → v1.4 Data Flow

```
CSV Data → DataFrame → v1.3 Engine → Signal → Backtest → Fill → Portfolio → Metrics
```

### Key Mappings

```python
# v1.3 Signal → Backtest Action
{
  'side': 'long',           # → 'action': 'long'
  'confidence': 0.65,       # → 'confidence': 0.65
  'entry': 50000,          # → price_hint for broker
  'stop': 48000,           # → 'stop': 48000
  'targets': [52000, ...], # → 'tp': [52000, 54000, 56000]
}
```

## 🛠️ Development Tips

1. **Start Simple**: Get basic buy/hold working first
2. **Add Complexity**: Layer in stops, TPs, exposure limits
3. **Validate**: Compare backtest results with forward testing
4. **Optimize Carefully**: Use walk-forward to avoid overfitting

## 📈 Expected Results

With proper implementation:

- **Realistic Performance**: Accounts for fees, slippage, stops
- **Risk Control**: Enforced position limits and exposure caps
- **Robust Validation**: Walk-forward prevents curve fitting
- **Actionable Insights**: Clear metrics for strategy improvement

## 🔍 Debugging

Enable detailed logging:

```python
import logging
logging.basicConfig(level=logging.DEBUG)
```

Check intermediate results:
```python
# In engine.py after each trade
print(f"Trade: {signal}, Fill: {fill}, Portfolio: {self.portfolio.equity()}")
```

## 🚀 Next Steps

1. **Implement TODOs** marked in the code
2. **Run on sample data** to validate pipeline
3. **Backtest v1.3** on historical data
4. **Compare with live results** for calibration
5. **Optimize parameters** using walk-forward
6. **Deploy improvements** to v1.5

---

The v1.4 framework provides the foundation for systematic strategy development and validation. It preserves your v1.3 signal generation while adding professional-grade backtesting capabilities.